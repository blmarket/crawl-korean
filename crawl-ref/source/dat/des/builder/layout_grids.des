###############################################################################
# layout_grids.des: Layouts based on grid structures generated by omnigrid
###############################################################################

: require("dlua/util.lua")
: require("dlua/layout/procedural.lua")
: require("dlua/layout/zonify.lua")
: require("dlua/layout/hyper.lua")
: require("dlua/layout/omnigrid.lua")

{{

  function render_grid(e, name, grid, paint)

    local gxm,gym = dgn.max_bounds()
    local build = {
      name = name,
      build_fixture = {
        { pass = "Primary", type = "build", strategy = hyper.place.strategy_primary, max_rooms = 1, generators = {
          { generator = "code", paint_callback = omnigrid_floor_plan, grid_options = grid, paint_options = paint,
            min_size_x = gxm-22, max_size_x = gxm-2, min_size_y = gym-22, max_size_y = gym-2,
            place_padding = 1, analyse = false }
        } }
      }
    }
    hyper.build_layout(e,build)

  end

  -- Generate a floor plan based on omnigrid subdivision
  function omnigrid_floor_plan(room,options,gen)

    local grid_options = (type(gen.grid_options) == "function") and gen.grid_options() or gen.grid_options
    local paint_options = gen.paint_options or {}
    paint_options.size = room.size

    local grid = omnigrid.subdivide(0,0,room.size.x-1,room.size.y-1,grid_options)

    local paint = {
      { type = "floor", corner1 = { x = 0, y = 0 }, corner2 = { x = room.size.x-1, y = room.size.y-1 }, usage = gen.usage_params }
    }

    return omnigrid.paint(grid, gen.paint_options, paint)

  end

  -- Draws a floor plan based on omnigrid
  function hyper.floors.floor_plan_omnigrid(room,options,gen)

    local paint = omnigrid.omnigrid_paint{
      guaranteed_divides = 0,
      subdivide_initial_chance = 80,  -- 20% chance of a donut
      fill_chance = 100,
      corridor_width = 8,
      minimum_size = 12,
      jitter = true,
      jitter_min = -2,
      jitter_max = 2,
      outer_corridor = true,
      size = room.size,
      paint_func = crawl.one_chance_in(3) and hyper.floors.cave_paint or nil,
      floor_func = crawl.one_chance_in(2) and hyper.floors.cave_paint or nil
    }
    return paint
  end

  function hyper.floors.floor_plan_finegrid(room,options,gen)
    local corridor_width = crawl.random_range(1,3)
    local jitters = {
      { weight = 20, jitter = false },
      { weight = 10, jitter = true, jitter_min = -3, jitter_max = 0 },
      -- With high jitter, it turns into really chaotic random architecture
      { weight = 5, jitter = true, jitter_min = -2, jitter_max = 1 },
      { weight = 5, jitter = true, jitter_min = -2, jitter_max = 2 }
    }
    local chosen = util.random_weighted_from("weight",jitters)

    local paint = omnigrid.omnigrid_paint{
      guaranteed_divides = 6,
      subdivide_initial_chance = 100,  -- 20% chance of a donut
      subdivide_level_multiplier = 0.98,
      corridor_width = corridor_width,
      fill_chance = 80,
      minimum_size = 6,
      jitter = chosen.jitter,
      jitter_min = chosen.jitter_min,
      jitter_max = chosen.jitter_max,
      size = room.size,
      paint_func = crawl.one_chance_in(3) and hyper.floors.cave_paint or nil,
      floor_func = crawl.one_chance_in(3) and hyper.floors.cave_paint or nil
    }
    return paint
  end

  function hyper.floors.floor_plan_microgrid(room,options,gen)
    local paint = omnigrid.omnigrid_paint{
      guaranteed_divides = 5,
      subdivide_initial_chance = 100,  -- 20% chance of a donut
      subdivide_level_multiplier = util.random_range_real(0.9,0.999),
      corridor_width = 1,
      fill_chance = crawl.random_range(50,90),
      minimum_size = 2,
      jitter = false,
      size = room.size,
      paint_func = crawl.one_chance_in(5) and hyper.floors.cave_paint or nil,
      floor_func = crawl.one_chance_in(4) and hyper.floors.cave_paint or nil
    }
    return paint
  end

}}

NAME:   layout_big_grid
DEPTH:  D:10-, Lair
WEIGHT: 10
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror
{{
  if is_validating() then return; end

  layout_type "open"
  local edge = crawl.x_chance_in_y(2,3)
  render_grid(_G, "Big Grid",
    {
      guaranteed_divides = edge and 0 or 2,
      -- 20% chance of a donut *if* we have an outer corridor
      subdivide_initial_chance = edge and 80 or 100,
      subdivide_level_multiplier = edge and 0.80 or 0.90,
      minimum_size = 16,
    },
    {
      fill_chance = 100,
      corridor_width = crawl.random_range(6,8),
      outer_corridor = edge,
      jitter = edge and crawl.coinflip(),
      jitter_min = -2,
      jitter_max = 2,
    } )

  zonify.grid_fill_zones(1, "rock_wall")
}}

NAME:   layout_small_grid
DEPTH:  Dis, D:5-, Lair
WEIGHT: 10
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror
{{
  if is_validating() then return; end

  layout_type "corridors"
  local edge = crawl.x_chance_in_y(1,4)

  render_grid(_G, "Small Grid",
    {
      guaranteed_divides = 4,
      subdivide_initial_chance = 120,
      subdivide_level_multiplier = .95,
      minimum_size = 6,
    },
    {
      fill_chance = 80,
      corridor_width = crawl.random_range(1,2),
      outer_corridor = edge,
      jitter = crawl.coinflip(),
      jitter_min = -1,
      jitter_max = crawl.random_range(0,1),
    } )
}}

NAME:   layout_long_grid
DEPTH:  Dis, D, Lair
WEIGHT: 10
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror
{{
  if is_validating() then return; end
  local min_size = you.in_branch("lair") and 1 or 2
  local max_size = you.in_branch("lair") and 4 or 3
  local size = crawl.random_range(min_size,max_size)
  layout_type "corridors"
  local grid_opts = {
    -- Keep subdividing until the areas are too small
    subdivide_initial_chance = 100,
    subdivide_level_multiplier = 1,
    minimum_size_x = size * 2,
    minimum_size_y = you.in_branch("dis")
                       and size * crawl.random_range(3,5)
                       or size * crawl.random_range(4,6),
  }
  local min_fill = 40 + size * 10
  local max_fill = 80 + size * 5

  local paint_opts = {
    fill_chance = crawl.random_range(min_fill,max_fill),
    corridor_width = size,
    outer_corridor = you.in_branch("lair"),
    jitter = false,
  }

  -- In D, for fairness, allow some narrow corridors (sometimes in Lair)
  if you.in_branch("D")
    or (you.in_branch("lair") and size>1 and crawl.one_chance_in(3)) then
    paint_opts.corridor_width = 1
    paint_opts.jitter = true
    paint_opts.jitter_min = -1
    paint_opts.jitter_max = 0
    if you.in_branch("D") then paint_opts.outer_corridor = crawl.coinflip() end
  end

  -- Choose an axis and switch sizes
  local which = "x"
  if crawl.coinflip() then
    which = "y"
    grid_opts.minimum_size_x,grid_opts.minimum_size_y = grid_opts.minimum_size_y,grid_opts.minimum_size_x
  end
  -- The effect this callback has is to keep subdividing a given axis
  -- until we reach the minimum size - *then* start dividing the other axis
  grid_opts.choose_axis = function(width,height,depth)
    return which
  end
  render_grid(_G, "Long Grid", grid_opts, paint_opts)
}}

# Generates up to 3 grids of different granularities, then layers
# then on top of each other. At its simplest reduction this looks like
# forbidden_donut but with a randomly-placed hole. At its most complex
# it does all kinds of interesting things.
NAME: layout_layered_grid
DEPTH:  D, Zot, Elf, Crypt, Snake, Dis, Lair
WEIGHT: 0
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_d
{{
  if is_validating() then return; end

  local weights = {
    { weight = 20, primary = hyper.floors.floor_plan_omnigrid },
    { weight = 30, primary = hyper.floors.floor_plan_finegrid },
    { weight = 50, primary = hyper.floors.floor_plan_microgrid },
    { weight = 10, primary = hyper.floors.floor_plan_omnigrid, secondary = hyper.floors.floor_plan_finegrid },
    { weight = 10, primary = hyper.floors.floor_plan_omnigrid, secondary = hyper.floors.floor_plan_microgrid },
    { weight = 10, primary = hyper.floors.floor_plan_finegrid, secondary = hyper.floors.floor_plan_microgrid },
    -- Very rare because it's somewhat liable to end up as a big mostly empty room
    { weight = 5, primary = hyper.floors.floor_plan_omnigrid, secondary = hyper.floors.floor_plan_finegrid, tertiary = hyper.floors.floor_plan_microgrid }
  }

  local chosen = util.random_weighted_from("weight",weights)

  local gxm,gym = dgn.max_bounds()
  local build = {
    name = "Hyper Grid",
    build_fixture = {
      { pass = "Primary", type = "build", strategy = hyper.place.strategy_primary, max_rooms = 1, generators = {
        { generator = "code", paint_callback = chosen.primary, min_size_x = gxm-22, max_size_x = gxm-2, min_size_y = gym-22, max_size_y = gym-2, place_padding = 1 }
      } },
      { pass = "Secondary", type = "build", strategy = hyper.place.strategy_primary, max_rooms = 1, enabled = chosen.secondary ~= nil, generators = {
        { generator = "code", paint_callback = chosen.secondary, min_size_x = gxm-22, max_size_x = gxm-2, min_size_y = gym-22, max_size_y = gym-2, place_padding = 1 }
      } },
      { pass = "Tertiary", type = "build", strategy = hyper.place.strategy_primary, max_rooms = 1, enabled = chosen.tertiary ~= nil, generators = {
        { generator = "code", paint_callback = chosen.tertiary, min_size_x = gxm-22, max_size_x = gxm-2, min_size_y = gym-22, max_size_y = gym-2, place_padding = 1 }
      } }
    }
  }

  hyper.build_layout(_G,build)
  zonify.grid_fill_zones(1, "rock_wall")
}}
